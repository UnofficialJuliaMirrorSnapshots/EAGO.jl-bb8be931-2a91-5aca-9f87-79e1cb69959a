var documenterSearchIndex = {"docs":
[{"location":"McCormick/usage/#Basic-Usage-1","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"McCormick/usage/#**Bounding-a-function-via-smooth-McCormick-objects**-1","page":"Basic Usage","title":"Bounding a function via smooth McCormick objects","text":"","category":"section"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"In order to bound a function using a McCormick relaxation. You first construct structure that bounds the input variables then you construct pass these variables two a function.","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"In the example below, convex/concave relaxations of the function f(x)=sin(2x)+exp(x)-x are calculated at x = 1 on the interval [-2,3].","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"using EAGO, IntervalArithmetic\n\n# create MC object for x = 2.0 on [1.0,3.0] for relaxing\n# a function f(x) on the interval Intv\n\nf(x) = x*(x-5.0)*sin(x)\n\nx = 2.0                          # value of independent variable x\nIntv = Interval(1.0,4.0)         # define interval to relax over\n\n# create McCormick object\nxMC = MC{1,NS}(x,Intv,1)\n\nfMC = f(xMC)             # relax the function\n\ncv = fMC.cv              # convex relaxation\ncc = fMC.cc              # concave relaxation\ncvgrad = fMC.cv_grad     # subgradient/gradient of convex relaxation\nccgrad = fMC.cc_grad     # subgradient/gradient of concave relaxation\nIv = fMC.Intv           # retrieve interval bounds of f(x) on Intv","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"The plotting the results we can easily generate visual the convex and concave relaxations, interval bounds, and affine bounds constructed using the subgradient at the middle of X.","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"(Image: Figure_1)","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"If we instead use the constructor xMC = MC{1,Diff}(x,Intv,1) in the above code, and then re-plot we arrive at the below graph","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"set_diff_relax!(1)","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"(Image: Figure_2)","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"This can readily be extended to multivariate functions as shown below","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"\nf(x) = max(x[1],x[2])\n\nx = [2.0 1.0]                                    # values of independent variable x\nIntv = [Interval(-4.0,5.0), Interval(-5.0,3.0)]  # define intervals to relax over\n\n# create McCormick object\nxMC = [MC{2,Diff}(x[i], Intv[i], i) for i=1:2)]\n\nfMC = f(xMC)            # relax the function\n\ncv = fMC.cv              # convex relaxation\ncc = fMC.cc              # concave relaxation\ncvgrad = fMC.cv_grad     # subgradient/gradient of convex relaxation\nccgrad = fMC.cc_grad     # subgradient/gradient of concave relaxation\nIv = fMC.Intv            # retrieve interval bounds of f(x) on Intv","category":"page"},{"location":"McCormick/usage/#","page":"Basic Usage","title":"Basic Usage","text":"(Image: Figure_3)","category":"page"},{"location":"Optimizer/high_performance/#High-Performance-Configuration-1","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"","category":"section"},{"location":"Optimizer/high_performance/#LP-Solver-Selection-1","page":"High-Performance Configuration","title":"LP Solver Selection","text":"","category":"section"},{"location":"Optimizer/high_performance/#","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"By default, EAGO uses GLPK for solving linear subproblems introduced. Using a commercial linear solver is highly recommended such as Gurobi, CPLEX, or XPRESS is highly recommended. Both Gurobi and CPLEX are free for academics and installation information can be found through http://www.gurobi.com/academia/academia-center and https://www.ibm.com/developerworks/community/blogs/jfp/entry/CPLEXIsFreeForStudents?lang=en, respectively.  ","category":"page"},{"location":"Optimizer/high_performance/#","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"A non-default LP solver can then be selected by the user via a series of keyword argument inputs as illustrated in the code snippet below. The relaxed_optimizer contains an instance optimizer with valid relaxations that are made at the root node and is updated with affine relaxations in place. Options can be passed to this optimizer using keyword arguments when initializing EAGO using the withoptimizer syntax in JuMP by defining an Iterators.Pairs structure assigning it to the `relaxedoptimizer_kwargs` keyword argument. MOI.","category":"page"},{"location":"Optimizer/high_performance/#","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"\n# Create opt EAGO Optimizer with CPLEX for use with MOI routines\nopt = EAGO.Optimizer(relaxed_optimizer = Gurobi.Optimizer(OutputFlag=0))\n\n# Create the same model m using an options dictionary in JuMP\nrelaxed_optimizer_kwargs = Dict{Symbol, Any}()\nopt_dict[:relaxed_optimizer] = Gurobi.Optimizer()\nopt_dict[:relaxed_optimizer_kwargs] = Iterators.Pairs([:OutputFlag], [0])\n\nm = JuMP.Model(with_optimizer(EAGO.Optimizer; opt_dict...))\n\n# Create the same model m is keyword arguments in JuMP\nm = JuMP.Model(with_optimizer(EAGO.Optimizer; relaxed_optimizer = Gurobi.Optimizer(),\n                                              relaxed_optimizer_kwargs = Iterators.Pairs([:OutputFlag], [0])))","category":"page"},{"location":"Optimizer/high_performance/#Ipopt-Build-1","page":"High-Performance Configuration","title":"Ipopt Build","text":"","category":"section"},{"location":"Optimizer/high_performance/#","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"Ipopt is the recommended solver for upper bounding problems. Ipopt's performance is highly dependent on the linear algebra package used (up to 30x). By default MUMPS is used. It's recommended that you either compile Ipopt with HSL MA57 or the Pardiso linear algebra packages with a machine specific Blas library (for Intel users the JuliaPro MKL version is recommended). For information on this, see the below links:","category":"page"},{"location":"Optimizer/high_performance/#","page":"High-Performance Configuration","title":"High-Performance Configuration","text":"Compiling Ipopt: https://www.coin-or.org/Ipopt/documentation/node13.html\nJulia Specifics:\nPointing Ipopt to a compiled version:\nIpopt Package Info: https://github.com/JuliaOpt/Ipopt.jl\nDiscourse discussion: https://discourse.julialang.org/t/use-ipopt-with-custom-version/9176\nIssues using Pardiso:\nUbuntu: https://github.com/JuliaOpt/Ipopt.jl/issues/106\nWindows: https://github.com/JuliaOpt/Ipopt.jl/issues/83\nHSL Website: http://www.hsl.rl.ac.uk/ipopt/\nPardiso Website: https://pardiso-project.org/","category":"page"},{"location":"McCormick/type/#**Types**-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"McCormick/type/#","page":"Types","title":"Types","text":"    McCormick.MC\n    McCormick.RelaxTag","category":"page"},{"location":"McCormick/type/#EAGO.McCormick.MC","page":"Types","title":"EAGO.McCormick.MC","text":"MC\n\nMC{N, T <: RelaxTag} <: Real is the McCormick (w/ (sub)gradient) structure which is used to overload standard calculations. The fields are:\n\ncc::Float64: Concave relaxation\ncv::Float64: Convex relaxation\ncc_grad::SVector{N,Float64}: (Sub)gradient of concave relaxation\ncv_grad::SVector{N,Float64}: (Sub)gradient of convex relaxation\nIntv::Interval{Float64}: Interval bounds\ncnst::Bool: Flag for whether the bounds are constant\n\n\n\n\n\n","category":"type"},{"location":"McCormick/type/#EAGO.McCormick.RelaxTag","page":"Types","title":"EAGO.McCormick.RelaxTag","text":"RelaxTag\n\nAn abstract type the subtypes of which define the manner of relaxation that will be performed for each operator applied to the MC object. Currently, the struct NS which specifies that standard (Mitsos 2009) are to be used is fully supported. Limited support is provided for differentiable McCormick relaxations specified by struct Diff (Khan 2017) and struct MV struct MV (Tsoukalas 2011.)\n\n\n\n\n\n","category":"type"},{"location":"McCormick/type/#**Constructors-for-MC**-1","page":"Types","title":"Constructors for MC","text":"","category":"section"},{"location":"McCormick/type/#","page":"Types","title":"Types","text":"    MC{N,T}(y::Float64)","category":"page"},{"location":"McCormick/type/#EAGO.McCormick.MC-Union{Tuple{Float64}, Tuple{N}, Tuple{T}} where T where N","page":"Types","title":"EAGO.McCormick.MC","text":"MC{N,T}(y::Interval{Float64})\n\nConstructs McCormick relaxation with convex relaxation equal to y.lo and concave relaxation equal to y.hi.\n\n\n\n\n\nMC{N,T}(y::Float64)\n\nConstructs McCormick relaxation with convex relaxation equal to y and concave relaxation equal to y.\n\n\n\n\n\nMC{N,T}(cv::Float64, cc::Float64)\n\nConstructs McCormick relaxation with convex relaxation equal to cv and concave relaxation equal to cc.\n\n\n\n\n\nMC{N,T}(val::Float64, Intv::Interval{Float64}, i::Int64)\n\nConstructs McCormick relaxation with convex relaxation equal to val, concave relaxation equal to val, interval bounds of Intv, and a unit subgradient with nonzero's ith dimension of length N.\n\n\n\n\n\n","category":"method"},{"location":"SemiInfinite/semiinfinite/#Solving-Semi-Infinite-Programming-1","page":"Semi-Infinite Programming","title":"Solving Semi-Infinite Programming","text":"","category":"section"},{"location":"SemiInfinite/semiinfinite/#","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"Matthew Wilhelm   Department of Chemical and Biomolecular Engineering, University of Connecticut","category":"page"},{"location":"SemiInfinite/semiinfinite/#Using-EAGO-to-solve-a-SIP-1","page":"Semi-Infinite Programming","title":"Using EAGO to solve a SIP","text":"","category":"section"},{"location":"SemiInfinite/semiinfinite/#","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"Semi-infinite programming remains an active area of research. In general, the solution of semi-infinite programs with nonconvex semi-infinite constraints of the below form are extremely challenging:","category":"page"},{"location":"SemiInfinite/semiinfinite/#","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"<img src=\"SIPProbFormulation.png\"      width = 50%      align=\"center\" />","category":"page"},{"location":"SemiInfinite/semiinfinite/#","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"EAGO implements the SIPres of [1] to determine a globally optimal solution to problems of the above form. This accomplished using the explicit_sip_solve function which returns the optimal value, the solution, and a boolean feasibility value. To illustrate the functions use, a simple example is presented here which solves the below problem:","category":"page"},{"location":"SemiInfinite/semiinfinite/#","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"<img src=\"SIPformulation.png\"      width = 65%      align=\"center\" />","category":"page"},{"location":"SemiInfinite/semiinfinite/#","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"using EAGO, JuMP\n\n# Define semi-infinite program\nf(x) = (1/3)*x[1]^2 + x[2]^2 + x[1]/2\ngSIP(x,p) = (1.0 - (x[1]^2)*(p[1]^2))^2 - x[1]*p[1]^2 - x[2]^2 + x[2]\n\nx_l = [-1000.0, -1000.0]\nx_u = [1000.0, 1000.0]\np_l = [0.0]\np_u = [1.0]\n\n# Solve the SIP  problem\nsip_result = explicit_sip_solve(x_l, x_u, p_l, p_u, f, gSIP)\n\nprintln(\"The global minimum of the semi-infinite program is between: $(sip_result.lower_bound) and $(sip_result.upper_bound).\")\nprintln(\"The global minimum is attained at: x = $(sip_result.xsol).\")\nprintln(\"Is the problem feasible? (sip_result.feasibility).\")","category":"page"},{"location":"SemiInfinite/semiinfinite/#Semi-infinite-solver-1","page":"Semi-Infinite Programming","title":"Semi-infinite solver","text":"","category":"section"},{"location":"SemiInfinite/semiinfinite/#","page":"Semi-Infinite Programming","title":"Semi-Infinite Programming","text":"    explicit_sip_solve\n    SIPProblem\n    SIPResult","category":"page"},{"location":"SemiInfinite/semiinfinite/#EAGO.explicit_sip_solve","page":"Semi-Infinite Programming","title":"EAGO.explicit_sip_solve","text":"explicitsipsolve\n\nSolve an SIP with decision variable bounds x_l to x_u, uncertain variable bounds p_l to p_u, an objective function of f, and gSIP seminfiniite constraint(s).\n\n\n\n\n\n","category":"function"},{"location":"SemiInfinite/semiinfinite/#EAGO.SIPProblem","page":"Semi-Infinite Programming","title":"EAGO.SIPProblem","text":"  SIPProblem\n\nStructure storing problem information for the solution routine.\n\n\n\n\n\n","category":"type"},{"location":"SemiInfinite/semiinfinite/#EAGO.SIPResult","page":"Semi-Infinite Programming","title":"EAGO.SIPResult","text":"  SIPResult\n\nStructure storing the results of the SIPres algorithm.\n\n\n\n\n\n","category":"type"},{"location":"Dev/future/#Future-Work-1","page":"Future Work","title":"Future Work","text":"","category":"section"},{"location":"Dev/future/#Current-Activity:-1","page":"Future Work","title":"Current Activity:","text":"","category":"section"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"Update CI testing.\nSpecialized algorithms for relaxing ODE constrained problems and solving","category":"page"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"global and robust optimization problems.","category":"page"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"Extensions for nonconvex dynamic global & robust optimization.\nProvide support for mixed-integer problems.\nUpdate EAGO to support nonsmooth problems (requires: a nonsmooth local nlp optimizer or lexiographic AD, support for relaxations is already included).\nPerformance assessment of nonlinear (differentiable) relaxations and incorporation into main EAGO routine.\nEvaluation and incorporation of implicit relaxation routines in basic solver.","category":"page"},{"location":"Dev/future/#Other-things-on-the-wishlist-(but-not-actively-being-worked-on):-1","page":"Future Work","title":"Other things on the wishlist (but not actively being worked on):","text":"","category":"section"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"Implement the interval constraint propagation scheme presented in Vu 2008. For","category":"page"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"improved convergences.","category":"page"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"A parametric bisection routine will be updated that can divide the (X,P)","category":"page"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"space into a series of boxes that all contain unique branches of the implicit function p->y(p).","category":"page"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"Provide a better interface the nonconvex semi-infinite programs solvers","category":"page"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"(JuMPeR extension?).","category":"page"},{"location":"Dev/future/#","page":"Future Work","title":"Future Work","text":"Add additional McCormick relaxations.\nAdd handling for domain reduction of special expression forms.","category":"page"},{"location":"Optimizer/domain_reduction/#Domain-Reduction-1","page":"Domain Reduction","title":"Domain Reduction","text":"","category":"section"},{"location":"Optimizer/domain_reduction/#Duality-Based-Bound-Tightening-1","page":"Domain Reduction","title":"Duality-Based Bound Tightening","text":"","category":"section"},{"location":"Optimizer/domain_reduction/#","page":"Domain Reduction","title":"Domain Reduction","text":"Variable bound tightening based on the duality multipliers are supported.","category":"page"},{"location":"Optimizer/domain_reduction/#","page":"Domain Reduction","title":"Domain Reduction","text":"variable_dbbt!","category":"page"},{"location":"Optimizer/domain_reduction/#EAGO.variable_dbbt!","page":"Domain Reduction","title":"EAGO.variable_dbbt!","text":"variable_dbbt!\n\nTightens the bounds of the _current_node using the current global upper bound and the duality information obtained from the relaxation.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#Special-Forms-1","page":"Domain Reduction","title":"Special Forms","text":"","category":"section"},{"location":"Optimizer/domain_reduction/#","page":"Domain Reduction","title":"Domain Reduction","text":"Bound tightening for linear forms, univariate quadratic forms, and bivariate quadratic forms are also supported.","category":"page"},{"location":"Optimizer/domain_reduction/#","page":"Domain Reduction","title":"Domain Reduction","text":"classify_quadratics!\nlp_bound_tighten\nunivariate_kernel\nunivariate_quadratic","category":"page"},{"location":"Optimizer/domain_reduction/#EAGO.classify_quadratics!","page":"Domain Reduction","title":"EAGO.classify_quadratics!","text":"classify_quadratics!\n\nClassifies constraints as univariate or bivariate and adds them to storage vectors.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.lp_bound_tighten","page":"Domain Reduction","title":"EAGO.lp_bound_tighten","text":"lp_bound_tighten\n\nPerforms the linear bound tightening.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.univariate_kernel","page":"Domain Reduction","title":"EAGO.univariate_kernel","text":"univariate_kernel\n\nKernel of the bound tightening operation on univariant qudaratic functions. Called for each univariate function.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.univariate_quadratic","page":"Domain Reduction","title":"EAGO.univariate_quadratic","text":"univariate_quadratic\n\nPerforms bound tightening on all univariate quadratic functions.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#Constraint-Propagation-1","page":"Domain Reduction","title":"Constraint Propagation","text":"","category":"section"},{"location":"Optimizer/domain_reduction/#","page":"Domain Reduction","title":"Domain Reduction","text":"EAGO contains a constraint propagation architecture that supported forward and reverse evaluation of set-valued functions on the directed acyclic graph (DAG). The interval contractor and reverse McCormick relaxation-based contractors are currently available.","category":"page"},{"location":"Optimizer/domain_reduction/#","page":"Domain Reduction","title":"Domain Reduction","text":"cpwalk","category":"page"},{"location":"Optimizer/domain_reduction/#EAGO.cpwalk","page":"Domain Reduction","title":"EAGO.cpwalk","text":"cpwalk\n\nPerforms forward-reverse pass on directed graph as part of constraint propagation.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#Optimization-Based-Bound-Tightening-1","page":"Domain Reduction","title":"Optimization-Based Bound Tightening","text":"","category":"section"},{"location":"Optimizer/domain_reduction/#","page":"Domain Reduction","title":"Domain Reduction","text":"EAGO makes use of an optimization-based bound tightening scheme using filtering and greedy ordering as detailed in: Gleixner, A.M., Berthold, T., Müller, B. et al. J Glob Optim (2017) 67: 731. https://doi.org/10.1007/s10898-016-0450-4","category":"page"},{"location":"Optimizer/domain_reduction/#","page":"Domain Reduction","title":"Domain Reduction","text":"aggressive_filtering!\naggressive_obbt_on_heurestic\nbool_indx_diff\nobbt\ntrivial_filtering!","category":"page"},{"location":"Optimizer/domain_reduction/#EAGO.aggressive_filtering!","page":"Domain Reduction","title":"EAGO.aggressive_filtering!","text":"aggressive_filtering!\n\nExcludes OBBT on variable indices after a search in a filtering direction.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.aggressive_obbt_on_heurestic","page":"Domain Reduction","title":"EAGO.aggressive_obbt_on_heurestic","text":"aggressive_obbt_on_heurestic\n\nRoutine that determines if aggressive filtering should be used. Currently, a user-specified option.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.bool_indx_diff","page":"Domain Reduction","title":"EAGO.bool_indx_diff","text":"bool_indx_diff\n\nUtility function used to set vector of booleans z to x & ~y. Avoids the generation of conversion of the BitArray created by broadcasting logical operators.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.obbt","page":"Domain Reduction","title":"EAGO.obbt","text":"obbt\n\nPerforms OBBT with filtering and greedy ordering as detailed in: Gleixner, A.M., Berthold, T., Müller, B. et al. J Glob Optim (2017) 67: 731. https://doi.org/10.1007/s10898-016-0450-4\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/domain_reduction/#EAGO.trivial_filtering!","page":"Domain Reduction","title":"EAGO.trivial_filtering!","text":"trivial_filtering!\n\nExcludes OBBT on variable indices that are tight for the solution of the relaxation.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO's-Branch-and-Bound-Routine-1","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"","category":"section"},{"location":"Optimizer/bnb_back/#","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"This component is meant to provide a flexible framework for implementing spatial branch-and-bound based optimization routines in Julia. All components of the branch-and-bound routine can be customized by the individual user: lower bounding problem, upper bounding problem.","category":"page"},{"location":"Optimizer/bnb_back/#Branch-and-Bound-Node-Storage-1","page":"EAGO's Branch and Bound Routine","title":"Branch and Bound Node Storage","text":"","category":"section"},{"location":"Optimizer/bnb_back/#","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.NodeBB","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.NodeBB","page":"EAGO's Branch and Bound Routine","title":"EAGO.NodeBB","text":"NodeBB\n\nStores information associated with each node in Branch & Bound tree.\n\nlower_variable_bounds::Vector{Float64}: Lower bounds of variable box.\nupper_variable_bounds::Vector{Float64}: Upper bounds of variable box.\nlower_bound::Float64: Lower bound of problem solution on nodeBB\nupper_bound::Float64: Upper bound of problem solution on nodeBB\ndepth::Int64: Depth of node in B&B tree.\nid::Int64: Unique id for each node.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/bnb_back/#Customizable-subroutines-1","page":"EAGO's Branch and Bound Routine","title":"Customizable subroutines","text":"","category":"section"},{"location":"Optimizer/bnb_back/#","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.add_cut!(t::ExtensionType, x::Optimizer)\n    EAGO.branch_node!(t::ExtensionType, x::Optimizer)\n    EAGO.convergence_check(t::ExtensionType, x::Optimizer)\n    EAGO.cut_condition(t::ExtensionType, x::Optimizer)\n    EAGO.fathom!(t::ExtensionType, d::Optimizer)\n    EAGO.lower_problem!(t::ExtensionType, x::Optimizer)\n    EAGO.relax_objective!(t::ExtensionType, x::Optimizer, x0::Vector{Float64})\n    EAGO.relax_problem!(t::ExtensionType, x::Optimizer, v::Vector{Float64}, q::Int64)\n    EAGO.node_selection!(t::ExtensionType, x::Optimizer)\n    EAGO.optimize_hook!(t::ExtensionType, x::Optimizer)\n    EAGO.postprocess!(t::ExtensionType, x::Optimizer)\n    EAGO.preprocess!(t::ExtensionType, x::Optimizer)\n    EAGO.repeat_check(t::ExtensionType, x::Optimizer)\n    EAGO.single_storage!(t::ExtensionType, x::Optimizer)\n    EAGO.termination_check(t::ExtensionType, x::Optimizer)\n    EAGO.upper_problem!(t::ExtensionType, x::Optimizer)","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.add_cut!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.add_cut!","text":"add_cut!(t::ExtensionType, x::Optimizer)\n\nAdds a cut for each constraint and the objective function to the subproblem.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.branch_node!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.branch_node!","text":"branch_node!(t::ExtensionType, x::Optimizer)\n\nCreates two nodes from currentnode using information available the x and stores them to the stack. By default, relative width bisection is perfomed at a point `branchpntwhich is a convex combination (parameter: branch_cvx_factor) of the solution to the relaxation and the midpoint of the node. If this solution lies withinbranchoffset/widthof a bound then the branch point is moved to a distance ofbranchoffset/width` from the bound.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.convergence_check-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.convergence_check","text":"convergence_check(t::ExtensionType, x::Optimizer)\n\nChecks for convergence of algorithm with respect to absolute and/or relative tolerances.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.cut_condition-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.cut_condition","text":"cut_conditioncut_condition(t::ExtensionType, x::Optimizer)\n\nChecks if a cut should be added and computes a new reference point to add the cut at. If no cut should be added the constraints not modified in place are deleted from the relaxed optimizer and the solution is compared with the interval lower bound. The best lower bound is then used.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.fathom!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.fathom!","text":"fathom!(t::ExtensionType, d::Optimizer)\n\nSelects and deletes nodes from stack with lower bounds greater than global upper bound.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.lower_problem!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.lower_problem!","text":"lower_problem!(t::ExtensionType, x::Optimizer)\n\nConstructs and solves the relaxation using the default EAGO relaxation scheme and optimizer on node y.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.relax_objective!-Tuple{ExtensionType,Optimizer,Array{Float64,1}}","page":"EAGO's Branch and Bound Routine","title":"EAGO.relax_objective!","text":"relax_objective!(t::ExtensionType, x::Optimizer, x0::Vector{Float64})\n\nA rountine that only relaxes the objective.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.relax_problem!-Tuple{ExtensionType,Optimizer,Array{Float64,1},Int64}","page":"EAGO's Branch and Bound Routine","title":"EAGO.relax_problem!","text":"relax_problem!(t::ExtensionType, x::Optimizer, v::Vector{Float64}, q::Int64)\n\nA rountine that updates the current node for the Evaluator and relaxes all nonlinear constraints and quadratic constraints.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.node_selection!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.node_selection!","text":"node_selection!(t::ExtensionType, x::Optimizer)\n\nSelects node with the lowest lower bound in stack.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.optimize_hook!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.optimize_hook!","text":"optimize_hook!(t::ExtensionType, x::Optimizer)\n\nProvides a hook for extensions to EAGO as opposed to standard global, local, or linear solvers.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.postprocess!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.postprocess!","text":"postprocess!(t::ExtensionType, x::Optimizer)\n\nDefault postprocess perfoms duality-based bound tightening on the y.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.preprocess!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.preprocess!","text":"preprocess!(t::ExtensionType, x::Optimizer)\n\nRuns interval, linear, quadratic contractor methods followed by obbt and a constraint programming walk up to tolerances specified in EAGO.Optimizer object.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.repeat_check-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.repeat_check","text":"repeat_check(t::ExtensionType, x::Optimizer)\n\nChecks to see if current node should be reprocessed.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.single_storage!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.single_storage!","text":"single_storage!(t::ExtensionType, x::Optimizer)\n\nStores the current node to the stack after updating lower/upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.termination_check-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.termination_check","text":"termination_check(t::ExtensionType, x::Optimizer)\n\nChecks for termination of algorithm due to satisfying absolute or relative tolerance, infeasibility, or a specified limit, returns a boolean valued true if algorithm should continue.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.upper_problem!-Tuple{ExtensionType,Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.upper_problem!","text":"upper_problem!(t::ExtensionType, x::Optimizer)\n\nDefault upper bounding problem which simply calls solve_local_nlp! to solve the nlp locally.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#Internal-Subroutines-1","page":"EAGO's Branch and Bound Routine","title":"Internal Subroutines","text":"","category":"section"},{"location":"Optimizer/bnb_back/#","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.cut_update(x::Optimizer)\n    EAGO.default_nlp_heurestic(x::Optimizer, y::NodeBB)\n    EAGO.interval_bound\n    EAGO.interval_lower_bound!(x::Optimizer, y::NodeBB)\n    EAGO.is_globally_optimal(t::MOI.TerminationStatusCode, r::MOI.ResultStatusCode)\n    EAGO.is_feasible_solution(t::MOI.TerminationStatusCode, r::MOI.ResultStatusCode)\n    EAGO.log_iteration!(x::Optimizer)\n    EAGO.same_box(x::NodeBB,y::NodeBB, atol::Float64)\n    EAGO.solve_local_nlp!(x::Optimizer)\n    EAGO.set_dual!(x::Optimizer)\n    EAGO.update_relaxed_problem_box!(x::Optimizer, y::NodeBB)","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.cut_update-Tuple{Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.cut_update","text":"cut_update(x::Optimizer)\n\nUpdates the internal storage in the optimizer after a valid feasible cut is added.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.default_nlp_heurestic-Tuple{Optimizer,NodeBB}","page":"EAGO's Branch and Bound Routine","title":"EAGO.default_nlp_heurestic","text":"default_nlp_heurestic(x::Optimizer, y::NodeBB)\n\nDefault check to see if the upper bounding problem should be run. By default, The upper bounding problem is run on every node up to depth upper_bounding_depth and is triggered with a probability of 0.5^(depth - upper_bounding_depth) afterwards.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.interval_bound","page":"EAGO's Branch and Bound Routine","title":"EAGO.interval_bound","text":"interval_bound\n\nComputes the natural interval extension of a MathOptInterface function s or ScalarQuadaraticFunction on a node y. Returns the lower bound if flag is true and the upper bound if flag is false.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.interval_lower_bound!-Tuple{Optimizer,NodeBB}","page":"EAGO's Branch and Bound Routine","title":"EAGO.interval_lower_bound!","text":"interval_lower_bound!(x::Optimizer, y::NodeBB)\n\nA fallback lower bounding problem that consists of an natural interval extension calculation. This is called when the optimizer used to compute the lower bound does not return a termination and primal status code indicating that it successfully solved the relaxation to a globally optimal point.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.is_globally_optimal-Tuple{MathOptInterface.TerminationStatusCode,MathOptInterface.ResultStatusCode}","page":"EAGO's Branch and Bound Routine","title":"EAGO.is_globally_optimal","text":"is_globally_optimal(t::MOI.TerminationStatusCode, r::MOI.ResultStatusCode)\n\nTakes an MOI.TerminationStatusCode and a MOI.ResultStatusCode and returns the tuple (valid_result::Bool, feasible::Bool). The value valid_result is true if the pair of codes prove that either the subproblem solution was solved to global optimality or the subproblem solution is infeasible. The value of feasible is true if the problem is feasible and false if the problem is infeasible.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.is_feasible_solution-Tuple{MathOptInterface.TerminationStatusCode,MathOptInterface.ResultStatusCode}","page":"EAGO's Branch and Bound Routine","title":"EAGO.is_feasible_solution","text":"is_feasible_solution(t::MOI.TerminationStatusCode, r::MOI.ResultStatusCode)\n\nTakes an MOI.TerminationStatusCode and a MOI.ResultStatusCode and returns true if this corresponds to a solution that is proven to be feasible. Returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.log_iteration!-Tuple{Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.log_iteration!","text":"log_iteration!(x::Optimizer)\n\nIf 'loggingon' is true, the 'globallowerbound', 'globalupperbound', 'runtime', and 'nodecount' are stored every 'loginterval'. If 'logsubprobleminfo' then the lower bound, feasibility and run times of the subproblems are logged every 'log_interval'.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.same_box-Tuple{NodeBB,NodeBB,Float64}","page":"EAGO's Branch and Bound Routine","title":"EAGO.same_box","text":"same_box(x::NodeBB,y::NodeBB, atol::Float64)\n\nChecks that node x and y have equal domains withing a tolerance of atol.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.solve_local_nlp!-Tuple{Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.solve_local_nlp!","text":"solve_local_nlp!(x::Optimizer)\n\nConstructs and solves the problem locally on on node y updated the upper solution informaton in the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.set_dual!-Tuple{Optimizer}","page":"EAGO's Branch and Bound Routine","title":"EAGO.set_dual!","text":"set_dual!(x::Optimizer)\n\nRetrieves the lower and upper duals for variable bounds from the relaxed_optimizer and sets the appropriate values in the _lower_lvd and _lower_uvd storage fields.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#EAGO.update_relaxed_problem_box!-Tuple{Optimizer,NodeBB}","page":"EAGO's Branch and Bound Routine","title":"EAGO.update_relaxed_problem_box!","text":"update_relaxed_problem_box!(x::Optimizer, y::NodeBB)\n\nUpdates the relaxed constraint by setting the constraint set of v == x*,xLi <= xi, andxi <= xUi` for each such constraint added to the relaxed optimizer.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/bnb_back/#Functions-for-generating-console-output-1","page":"EAGO's Branch and Bound Routine","title":"Functions for generating console output","text":"","category":"section"},{"location":"Optimizer/bnb_back/#","page":"EAGO's Branch and Bound Routine","title":"EAGO's Branch and Bound Routine","text":"    EAGO.print_iteration!\n    EAGO.print_node!\n    EAGO.print_results!\n    EAGO.print_solution!","category":"page"},{"location":"Optimizer/bnb_back/#EAGO.print_iteration!","page":"EAGO's Branch and Bound Routine","title":"EAGO.print_iteration!","text":"print_iteration!\n\nPrints the iteration information based on verbosity. The header is displayed every header_interval, the iteration info is displayed every iteration_interval.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.print_node!","page":"EAGO's Branch and Bound Routine","title":"EAGO.print_node!","text":"print_node!\n\nPrints node information for the B&B problem. Node id, bound, and interval box.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.print_results!","page":"EAGO's Branch and Bound Routine","title":"EAGO.print_results!","text":"print_results!\n\nPrints the results of a single bounding problem.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/bnb_back/#EAGO.print_solution!","page":"EAGO's Branch and Bound Routine","title":"EAGO.print_solution!","text":"print_solution!\n\nPrints solution information for the B&B problem. Displays first node found, solution value, solution, and time spent solving subproblems.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#Relaxation-Backend-1","page":"Relaxation Backend","title":"Relaxation Backend","text":"","category":"section"},{"location":"Optimizer/relax_back/#Quadratic-Relaxations-1","page":"Relaxation Backend","title":"Quadratic Relaxations","text":"","category":"section"},{"location":"Optimizer/relax_back/#","page":"Relaxation Backend","title":"Relaxation Backend","text":"    EAGO.relax_convex_kernel\n    EAGO.relax_nonconvex_kernel\n    EAGO.relax_quadratic_gen_saf\n    EAGO.relax_quadratic!","category":"page"},{"location":"Optimizer/relax_back/#EAGO.relax_convex_kernel","page":"Relaxation Backend","title":"EAGO.relax_convex_kernel","text":"relax_convex_kernel\n\nStores the kernel of the calculation required to relax convex quadratic constraints using the immutable dictionary to label terms.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.relax_nonconvex_kernel","page":"Relaxation Backend","title":"EAGO.relax_nonconvex_kernel","text":"relax_nonconvex_kernel\n\nStores the kernel of the calculation required to relax nonconvex quadratic constraints using the immutable dictionary to label terms.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.relax_quadratic_gen_saf","page":"Relaxation Backend","title":"EAGO.relax_quadratic_gen_saf","text":"relax_quadratic_gen_saf\n\nDefault routine for relaxing nonconvex quadratic constraint lower < func < upper on node n. Takes affine bounds of convex part at point x0 and secant line bounds on concave parts.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.relax_quadratic!","page":"Relaxation Backend","title":"EAGO.relax_quadratic!","text":"relax_quadratic!\n\nRelaxes all quadratic constraints in x optimizer.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#Nonlinear-Relaxation-1","page":"Relaxation Backend","title":"Nonlinear Relaxation","text":"","category":"section"},{"location":"Optimizer/relax_back/#","page":"Relaxation Backend","title":"Relaxation Backend","text":"EAGO.relax_nlp!\nEAGO.objective_cut_linear!","category":"page"},{"location":"Optimizer/relax_back/#EAGO.relax_nlp!","page":"Relaxation Backend","title":"EAGO.relax_nlp!","text":"relax_nlp!\n\nA rountine that relaxes all nonlinear constraints excluding constraints specified as quadratic.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#EAGO.objective_cut_linear!","page":"Relaxation Backend","title":"EAGO.objective_cut_linear!","text":"objective_cut_linear!\n\nAdds linear objective cut constraint to the x.relaxed_optimizer.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/relax_back/#Nonlinear-Storage-Structures-1","page":"Relaxation Backend","title":"Nonlinear Storage Structures","text":"","category":"section"},{"location":"Optimizer/relax_back/#","page":"Relaxation Backend","title":"Relaxation Backend","text":"    FunctionSetStorage\n    SubexpressionSetStorage","category":"page"},{"location":"Optimizer/relax_back/#EAGO.FunctionSetStorage","page":"Relaxation Backend","title":"EAGO.FunctionSetStorage","text":"FunctionSetStorage\n\nA storage object for both set and number valued data required to compute relaxations which contains the tape used to compute a nonlinear function. The object is parameterized by a {N,T<:RelaxTag} where N corresponds the subgradient size used in the MC object.\n\nnd::Vector{JuMP.NodeData}\nadj::SparseMatrixCSC{Bool,Int64}\nconst_values::Vector{Float64}\nsetstorage::Vector{MC{N,T}}\nnumberstorage::Vector{Float64}\nnumvalued::Vector{Bool}\ntp1storage::Vector{Float64}\ntp2storage::Vector{Float64}\ntp3storage::Vector{Float64}\ntp4storage::Vector{Float64}\ntpdict::Dict{Int64,Tuple{Int64,Int64,Int64,Int64}}\ngrad_sparsity::Vector{Int64}\nhess_I::Vector{Int64}\nhess_J::Vector{Int64}\ndependent_subexpressions::Vector{Int64}\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/relax_back/#EAGO.SubexpressionSetStorage","page":"Relaxation Backend","title":"EAGO.SubexpressionSetStorage","text":"SubexpressionSetStorage\n\nA storage object for both set and number valued data required to compute relaxations  which contains the tape used to compute a nonlinear subexpression. The object is parameterized by a {N,T<:RelaxTag} where N corresponds the the subgradient size used in the MC object.\n\nnd::Vector{JuMP.NodeData}\nadj::SparseMatrixCSC{Bool,Int64}\nconst_values::Vector{Float64}\nsetstorage::Vector{MC{N,T}}\nnumberstorage::Vector{Float64}\nnumvalued::Vector{Bool}\ntp1storage::Vector{Float64}\ntp2storage::Vector{Float64}\ntp3storage::Vector{Float64}\ntp4storage::Vector{Float64}\ntpdict::Dict{Int64,Tuple{Int64,Int64,Int64,Int64}}\nlinearity::JuMP._Derivatives.Linearity\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/relax_back/#Nonlinear-Evaluator-1","page":"Relaxation Backend","title":"Nonlinear Evaluator","text":"","category":"section"},{"location":"Optimizer/relax_back/#","page":"Relaxation Backend","title":"Relaxation Backend","text":"    Evaluator","category":"page"},{"location":"Optimizer/relax_back/#EAGO.Evaluator","page":"Relaxation Backend","title":"EAGO.Evaluator","text":"Evaluator\n\nMOI.AbstractNLPEvaluator for calculating relaxations of nonlinear terms.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/relax_back/#Internal-Functions-Used-by-Evaluator-1","page":"Relaxation Backend","title":"Internal Functions Used by Evaluator","text":"","category":"section"},{"location":"Optimizer/relax_back/#","page":"Relaxation Backend","title":"Relaxation Backend","text":"    set_current_node!(x::Evaluator, n::NodeBB)\n    eval_objective_lo(d::Evaluator)\n    eval_constraint_cc(d::Evaluator, g::Vector{Float64}, y::Vector{Float64})\n    eval_constraint_lo!(d::Evaluator, g::Vector{Float64})\n    eval_constraint_hi!(d::Evaluator, g::Vector{Float64})\n    eval_constraint_cc_grad(d::Evaluator, g, y)\n    get_node_lower(d::FunctionSetStorage, i::Int64)\n    get_node_upper(d::FunctionSetStorage, i::Int64)\n    forward_reverse_pass(d::Evaluator, x::Vector{Float64})","category":"page"},{"location":"Optimizer/relax_back/#EAGO.set_current_node!-Tuple{Evaluator,NodeBB}","page":"Relaxation Backend","title":"EAGO.set_current_node!","text":"set_current_node!(x::Evaluator, n::NodeBB)\n\nSets the current node in the Evaluator structure.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/relax_back/#EAGO.eval_objective_lo-Tuple{Evaluator}","page":"Relaxation Backend","title":"EAGO.eval_objective_lo","text":"eval_objective_lo\n\nRetrieves the lower bound of the objective.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/relax_back/#EAGO.eval_constraint_cc-Tuple{Evaluator,Array{Float64,1},Array{Float64,1}}","page":"Relaxation Backend","title":"EAGO.eval_constraint_cc","text":"eval_constraint_cc(d::Evaluator, g::Vector{Float64}, y::Vector{Float64})\n\nPopulates g with the concave relaxations of the constraints of d evaluated at y.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/relax_back/#EAGO.eval_constraint_lo!-Tuple{Evaluator,Array{Float64,1}}","page":"Relaxation Backend","title":"EAGO.eval_constraint_lo!","text":"eval_constraint_lo!(d::Evaluator, g::Vector{Float64})\n\nPopulates g with the lower bounds of the constraints of d.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/relax_back/#EAGO.eval_constraint_hi!-Tuple{Evaluator,Array{Float64,1}}","page":"Relaxation Backend","title":"EAGO.eval_constraint_hi!","text":"eval_constraint_hi!(d::Evaluator, g::Vector{Float64})\n\nPopulates g with the upper bounds of the constraints of d.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/relax_back/#EAGO.eval_constraint_cc_grad-Tuple{Evaluator,Any,Any}","page":"Relaxation Backend","title":"EAGO.eval_constraint_cc_grad","text":"eval_constraint_cc_grad(d::Evaluator, g, y)\n\nPopulates g with the subgradients of the constraints of d evaluated at y.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/relax_back/#EAGO.get_node_lower-Tuple{FunctionSetStorage,Int64}","page":"Relaxation Backend","title":"EAGO.get_node_lower","text":"get_node_lower(d::FunctionSetStorage, i::Int64)\n\nRetreives the lower bound of ith term in the tape of d.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/relax_back/#EAGO.get_node_upper-Tuple{FunctionSetStorage,Int64}","page":"Relaxation Backend","title":"EAGO.get_node_upper","text":"get_node_upper(d::FunctionSetStorage, i::Int64)\n\nRetreives the upper bound of ith term in the tape of d.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/relax_back/#EAGO.forward_reverse_pass-Tuple{Evaluator,Array{Float64,1}}","page":"Relaxation Backend","title":"EAGO.forward_reverse_pass","text":"forward_reverse_pass(d::Evaluator, x::Vector{Float64})\n\nPerforms a d.fw_repeats forward passes of the set-value evaluator each followed by a reverse pass if d.has_reverse as long as the node between passes differs by more that d.fw_atol at each iteration.\n\n\n\n\n\n","category":"method"},{"location":"Optimizer/udf_utilities/#User-Define-Functions-and-DAG-Utilities-1","page":"User-Define Functions and DAG Utilities","title":"User-Define Functions and DAG Utilities","text":"","category":"section"},{"location":"Optimizer/udf_utilities/#","page":"User-Define Functions and DAG Utilities","title":"User-Define Functions and DAG Utilities","text":"EAGO has included basic functionality to manipulate user-defined functions. These features are largely experimental and we're interested in providing additional for novel use cases. Please contact us by opening an issue in the Github issue tracker with any questions or requests for additional features.","category":"page"},{"location":"Optimizer/udf_utilities/#DAG-Substitution-and-Flattening-1","page":"User-Define Functions and DAG Utilities","title":"DAG Substitution and Flattening","text":"","category":"section"},{"location":"Optimizer/udf_utilities/#","page":"User-Define Functions and DAG Utilities","title":"User-Define Functions and DAG Utilities","text":"dag_flattening!\nflatten_expression!\nregister_substitution!\nTemplate_Graph\nTemplate_Node","category":"page"},{"location":"Optimizer/udf_utilities/#EAGO.Script.dag_flattening!","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.dag_flattening!","text":"dag_flattening!\n\nFlattens (usually) the dag by making all registered substitutions for every nonlinear term in the Optimizer.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/udf_utilities/#EAGO.Script.flatten_expression!","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.flatten_expression!","text":"flatten_expression!\n\nFlattens (usually) the dag by making all registered substitutions for the expression expr::_NonlinearExprData. Performs a depth-first search through the expression adding the terminal node to the stack, then checking to determine if it matches a registered substitution pattern. If it doesn't not then node is added to the new expression graph representation and it's children are added to the queue. If an expression (node) is identified as a pattern then it is substituted and any children expression nodes are then checked for patterns until the depth first search is exhausted.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/udf_utilities/#EAGO.Script.register_substitution!","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.register_substitution!","text":"register_substitution!\n\nSpecifies that the src::Template_Graph should be subsituted out for the trg::Template_Graph.\n\nConventions for substition, the expression to be checked always appears at key 1 in the Template_Graph and operations are ordered from low value to high value left to right so if 1 is a -, and 4 => 1, 3 => 1 then the expression is 4 - 3\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/udf_utilities/#EAGO.Script.Template_Graph","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.Template_Graph","text":"Template_Graph\n\nHolds a list of Template_Nodes, set of directed edges, lengths, an adjacency matrix and the number of children.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/udf_utilities/#EAGO.Script.Template_Node","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.Template_Node","text":"Template_Node\n\nA structure which holds a symbol indicating whether the node is an operator, a number, or an expression type, a value which identifies the function or symbol value, potentially a numeric value num_value, and a check that can be run to verify the node is correct check.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/udf_utilities/#User-Defined-Function-(UDF)-Scrubber-1","page":"User-Define Functions and DAG Utilities","title":"User-Defined Function (UDF) Scrubber","text":"","category":"section"},{"location":"Optimizer/udf_utilities/#","page":"User-Define Functions and DAG Utilities","title":"User-Define Functions and DAG Utilities","text":"scrub\nscrub!","category":"page"},{"location":"Optimizer/udf_utilities/#EAGO.Script.scrub","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.scrub","text":"scrub(f::Function, n::Int, inplace = false)\n\nReplaces storage objects and circumvents assertions that present a UDF from being overloaded with subtype Real objects by creating a function which overdubs f in ScrubCtx.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/udf_utilities/#EAGO.Script.scrub!","page":"User-Define Functions and DAG Utilities","title":"EAGO.Script.scrub!","text":"scrub!(d::_NLPData)\n\nApplies scrub to every user-defined function in the a _NLPData structure.\n\n\n\n\n\n","category":"function"},{"location":"Dev/contributing/#How-to-Contribute-1","page":"How to Contribute","title":"How to Contribute","text":"","category":"section"},{"location":"Dev/contributing/#","page":"How to Contribute","title":"How to Contribute","text":"We're always happy to welcome work with additional collaborators and contributors. One of the easy ways for newcomers to contribute is by adding additional relaxations.","category":"page"},{"location":"Dev/contributing/#","page":"How to Contribute","title":"How to Contribute","text":"If you're interested in contributing in larger ways, please contact: Matthew Wilhelm","category":"page"},{"location":"Dev/contributing/#","page":"How to Contribute","title":"How to Contribute","text":"If you have any requests for additional functionality, bug fixes, or comments please feel free to open a new issue using Github issue tracker.","category":"page"},{"location":"McCormick/implicit/#Relaxation-of-Implicit-Functions-1","page":"Relaxation of Implicit Functions","title":"Relaxation of Implicit Functions","text":"","category":"section"},{"location":"McCormick/implicit/#High-level-functions-1","page":"Relaxation of Implicit Functions","title":"High-level functions","text":"","category":"section"},{"location":"McCormick/implicit/#","page":"Relaxation of Implicit Functions","title":"Relaxation of Implicit Functions","text":"  implicit_relax_h!\n  implicit_relax_fg\n  implicit_relax_f","category":"page"},{"location":"McCormick/implicit/#EAGO.McCormick.implicit_relax_h!","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.implicit_relax_h!","text":"implicit_relax_h!\n\nRelaxes the implicit function determined by h(x,p) with x in X and p in P. The reference point for the affine relaxations is pmid. The parameters generated from the relaxation at pmid are param and the basic parameters of the fixed point method are mc_opt.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#EAGO.McCormick.implicit_relax_fg","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.implicit_relax_fg","text":"implicit_relax_fg\n\nRelaxes the functions f(x,p) and g(x,p) by relaxation the state variable x using the implicit function determined by h(x,p) with x in X and p in P. The reference point for the affine relaxations is pmid. The parameters generated from the relaxation at pmid are param and the basic parameters of the fixed point method are mc_opt.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#EAGO.McCormick.implicit_relax_f","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.implicit_relax_f","text":"implicit_relax_f\n\nRelaxes the function f(x,p) by relaxation the state variable x using the implicit function determined by h(x,p) with x in X and p in P. The reference point for the affine relaxations is pmid. The parameters generated from the relaxation at pmid are param and the basic parameters of the fixed point method are mc_opt.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#Subroutines-1","page":"Relaxation of Implicit Functions","title":"Subroutines","text":"","category":"section"},{"location":"McCormick/implicit/#","page":"Relaxation of Implicit Functions","title":"Relaxation of Implicit Functions","text":"    affine_exp!\n    correct_exp!\n    final_cut\n    gen_expansion_params!\n    mc_dense_krawczyk_cw!\n    mc_dense_newton_gs!\n    pmc_kernel!","category":"page"},{"location":"McCormick/implicit/#EAGO.McCormick.affine_exp!","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.affine_exp!","text":"affine_exp!\n\nComputates the affine relaxations of the state variable. Inputs are:\n\nx: State variable relaxation\np::Vector{MC{N,T}}: Decision variable relaxation\np_ref::Vector{MC{N,T}}: Reference variable relaxation\nxa::Vector{MC{N,T}}: Lower affine relaxation of the state variable\nxA::Vector{MC{N,T}}: Upper affine relaxation of the state variable\nz::Vector{MC{N,T}}: Affine function in X\nnx: Number of state variables\nlambda: Convex coefficient used to define z as a function of xa, xA\n\nPopulats the following vectors with results (xa,xA,z):\n\nxa::Vector{MC{N,T}}: Lower affine relaxation of the state variable\nxA::Vector{MC{N,T}}: Upper affine relaxation of the state variable\nz::Vector{MC{N,T}}: Affine function in X\n\n\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#EAGO.McCormick.correct_exp!","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.correct_exp!","text":"correct_exp!\n\nCorrects the relaxation of the state variable x_mc if the affine relaxation, 'z_mc', exceeds the interval bounds xL or xU.\n\nz_mc::Vector{MC{N}}: Affine relaxation\nx_mc::Vector{MC{N}}: Relaxation of state variable\nX::Vector{IntervalType}: Lower bound on state vector\nnx::Int64: Size of the state vector\nepsv::Float64: Tolerance for checking that subgradient exceeds bound\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#EAGO.McCormick.final_cut","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.final_cut","text":"final_cut\n\nAn operator that cuts the x_mc object using the x_mc_int bounds in a differentiable or nonsmooth fashion to achieve a composite relaxation within x_mc_int.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#EAGO.McCormick.gen_expansion_params!","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.gen_expansion_params!","text":"gen_expansion_params!\n\nGenerates the relaxations at pref_mc that can be subsequentially used to compute affine relaxations for use in relaxing the implicit function.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#EAGO.McCormick.mc_dense_krawczyk_cw!","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.mc_dense_krawczyk_cw!","text":"mc_dense_krawczyk_cw!\n\nPerforms a single step of the dense-krawczyk componentwise parametric method after the inputs have been preconditioned.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#EAGO.McCormick.mc_dense_newton_gs!","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.mc_dense_newton_gs!","text":"mc_dense_newton_gs!\n\nPerforms a single step of the dense-newton gauss-siedel parametric method after the inputs have been preconditioned.\n\n\n\n\n\n","category":"function"},{"location":"McCormick/implicit/#EAGO.McCormick.pmc_kernel!","page":"Relaxation of Implicit Functions","title":"EAGO.McCormick.pmc_kernel!","text":"pmc_kernel!\n\nPeforms the following steps in sequence:\n\nEvaluates the function h!(H, x, xp, p, t) in place with x = z_mc, p = p_mc,\n\nxp = xp_mc, t = flt_param and preconditions H using an interval midpoint preconditioner if precond = true.\n\nEvaluates the function hj!(J, x, xp, p, t) in place with x = aff_mc, p = p_mc,\n\nxp = xp_mc, t = flt_param and preconditions J using an interval midpoint preconditioner if precond = true.\n\nLastly, applies a Newton-type contractor method. The parametric GS Newton\n\ncontractor if cntr = :Newton and the componentwise Krawczyk contractor otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Optimizer/optimizer/#EAGO-Optimizer-1","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"","category":"section"},{"location":"Optimizer/optimizer/#","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"The EAGO.Optimizer object holds all algorithm solution information. A description of all user-facing options has been provided in the docstring.","category":"page"},{"location":"Optimizer/optimizer/#EAGO.Optimizer-1","page":"EAGO Optimizer","title":"EAGO.Optimizer","text":"","category":"section"},{"location":"Optimizer/optimizer/#","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"Optimizer","category":"page"},{"location":"Optimizer/optimizer/#EAGO.Optimizer","page":"EAGO Optimizer","title":"EAGO.Optimizer","text":"Optimizer\n\nThe main optimizer object used by EAGO to solve problems during the optimization routine. The following commonly used options are described below and can be set via keyword arguments in the JuMP/MOI model:\n\npresolve_scrubber_flag::Bool: Replace code in user-defined functions which                                 may prevent method overloading on Real subtypes                                 (default = false).\npresolve_to_JuMP_flag::Bool: Create and use DAG representations of user-defined                                function (default = false).\npresolve_epigraph_flag::Bool: [FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED]                                 Apply the epigraph reformulation to the problem                                 (default = false).\npresolve_cse_flag::Bool: [FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Enable                            common subexpression elimination for DAG (default = false).\npresolve_flatten_flag::Bool: Rerranges the DAG using registered transformations                                (default = false)\ncp_depth::Int64: Depth in B&B tree above which constraint propagation should                    be disabled (default = 1000).\ncp_repetitions::Int64: Number of repetitions of forward-reverse passes to perform in                         constraint propagation (default = 3).\ncp_tolerance::Float64: Disable constraint propagation if the ratio of new node                          volume to beginning node volume exceeds this number                          (default = 0.99).\ncp_interval_only::Bool: Use only valid interval bounds during constraint                           propagation (default = false).\nrelaxed_optimizer::S: An instance of the optimizer used to solve the relaxed                         subproblems (default = GLPK.Optimizer()).\nrelaxed_optimizer_kwargs::Base.Iterators.Pairs: Keyword arguments for the                                                   relaxed optimizer.\nobbt_depth::Int64: Depth in B&B tree above which OBBT should                    be disabled (default = 1000).\nobbt_repetitions::Int64: Number of repetitions of OBBT to perform in                           preprocessing (default = 3).\nobbt_aggressive_on::Bool: Turn aggresive OBBT on (default = false).\nobbt_aggressive_max_iteration::Int64: Maximum iteration to perform aggresive                                         OBBT (default = 2)\nobbt_aggressive_min_dimension::Int64: Minimum dimension to perform aggresive                                         OBBT (default = 2)\nobbt_tolerance::Float64: Tolerance to consider bounds equal (default = 1E-9).\nobbt_variable_values::Vector{Bool}: Variables to perform OBBT on                                       (default: all variables in nonlinear expressions).\nlp_depth::Int64: Depth in B&B tree above which linear FBBT should                    be disabled (default = 1000).\nlp_repetitions::Int64: Number of repetitions of linear FBBT to perform in                           preprocessing (default = 3).\nquad_uni_depth::Int64: Depth in B&B tree above which univariate quadratic                          FBBT should be disabled (default = -1).\nquad_uni_repetitions::Int64: Number of repetitions of univariate quadratic FBBT                                to perform in preprocessing (default = 2).\nquad_bi_depth::Int64: [FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Depth in                         B&B tree above which bivariate quadratic FBBT should                         be disabled (default = -1).\nquad_bi_repetitions::Int64: Number of repetitions of bivariate quadratic FBBT                                to perform in preprocessing (default = 2).\nsubgrad_tighten::Bool: Perform tightening of interval bounds using subgradients                          at each factor in each nonlinear tape during a forward-reverse                          pass (default = true).\nsubgrad_tighten_reverse::Bool: [FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED] Used to                                  enable/disable subgradient tightening of interval                                  bounds on the reverse pass (default = true).\ncut_max_iterations::Int64\ncut_cvx::Float64: Convex coefficient used to select point for new added cuts.                     Branch point is given by (1-cut_cvx)*xmid + cut_cvx*xsol                     (default = 0.9).\ncut_tolerance::Float64: Add cut if the L1 distance from the prior cutting point                           to the new cutting point normalized by the box volume                           is greater than the tolerance (default = 0.05).\nobjective_cut_on::Bool: Adds an objective cut to the relaxed problem (default = true).\nupper_optimizer::T: Optimizer used to solve upper bounding problem (default = Ipopt.Optimizer())\nupper_factory::JuMP.OptimizerFactory: OptimizerFactory used to build optimizer that                                         solves the upper bounding problem                                         (default = with_optimizer(Ipopt.Optimizer, kwargs),                                         check Optimizer constructor for kwargs used).\nupper_bounding_depth::Int64: Solve upper problem for every node with depth                                less than upper_bounding_depth and with a probability                                of (1/2)^(depth-upperboundingdepth) otherwise                                (default = 4).\ndbbt_depth::Int64: Depth in B&B tree above which duality-based bound tightening                      should be disabled (default = 1E10).\ndbbt_tolerance::Float64: New bound is considered equal to the prior bound                            if within dbbt_tolerance (default = 1E-9).\nbranch_cvx_factor::Float64: Convex coefficient used to select branch point.                               Branch point is given by                               branch_cvx_factor*xmid + (1-branch_cvx_factor)*xsol                               (default = 0.25)\nbranch_offset::Float64: Minimum distance from bound to have branch point                           normalized by width of dimension to branch on                           (default = 0.15)\nbranch_variable::Vector{Bool}: Variables to branch on (default is all nonlinear).\nbranch_max_repetitions::Int64: [FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED]                                  Number of times repeat node processing prior                                  to branching (default = 4).\nbranch_repetition_tol::Float64: [FUTURE FEATURE, NOT CURRENTLY IMPLEMENTED]                                   Volume ratio tolerance required to repeat                                   processing the current node (default = 0.9).\nrounding_mode::Symbol: Interval rounding mode to use (default = :accurate)\nnode_limit::Int64: Node limit  (default = 10^7).\ntime_limit::Float64: Time limit in seconds (default = 3600).\niteration_limit::Int64: Iteration limit (default = 3000000).\nabsolute_tolerance::Float64: Absolute tolerance for terminatin (default = 1E-3).\nrelative_tolerance::Float64: Relative tolerance for terminatin (default = 1E-3).\nlocal_solve_only::Bool: Perform only a local solve of the problem (default = false).\nlog_on::Bool: Turns logging on records global bounds, node count and run time.                 Additional options are available for recording information specific                 to subproblems (default = false).\nlog_subproblem_info::Bool: Turns on logging of times and feasibility of                              subproblems (default = false).\nlog_interval::Int64: Log data every log_interval iterations (default = 1).\nverbosity::Int64: The amount of information that should be printed to console                     while solving values range from 0 - 4: 0 is silent, 1 shows                     iteration summary statistics only, 2-4 show varying degrees                     of details about calculations within each iteration                     (default = 1).\noutput_iterations::Int64: Display summary of iteration to console every                            output_iterations (default = 10).\nheader_iterations::Int64: Display header for summary to console every                            output_iterations (default = 100).\nenable_optimize_hook::Bool: Specifies that the optimize_hook! function should                               be called rather than throw the problem to the                               standard B&B routine (default = false).\next::Dict{Symbol, Any}: Holds additional storage needed for constructing                           extensions to EAGO (default = Dict{Symbol,Any}).\next_type::ExtensionType: Holds an instance of a subtype of EAGO.ExtensionType                            used to define new custom subroutines                            (default = DefaultExt()).\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#Internal-Storage-Structures-1","page":"EAGO Optimizer","title":"Internal Storage Structures","text":"","category":"section"},{"location":"Optimizer/optimizer/#","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"VariableInfo\nExtensionType\nLog","category":"page"},{"location":"Optimizer/optimizer/#EAGO.VariableInfo","page":"EAGO Optimizer","title":"EAGO.VariableInfo","text":"VariableInfo\n\nA structure used to store information related to the bounds assigned to each variable.\n\nis_integer::Bool:      Is the variable integer valued?\nlower_bound::Float64:  May be -Inf even if haslowerbound == true\nhas_lower_bound::Bool: Implies lower_bound == Inf\nupper_bound::Float64:  May be Inf even if hasupperbound == true\nhas_upper_bound::Bool: Implies upper_bound == Inf\nis_fixed::Bool:        Implies lowerbound == upperbound and                          !haslowerbound and !hasupperbound.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#EAGO.ExtensionType","page":"EAGO Optimizer","title":"EAGO.ExtensionType","text":"ExtensionType\n\nAn abstract type the subtypes of which are associated with functions method overloaded for for new extensions. An instance of the DefaultExt <:ExtensionType structure to the Optimizer in the ext_type field.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#EAGO.Log","page":"EAGO Optimizer","title":"EAGO.Log","text":"Log\n\nA structure used to store information on the history of the solution procedure for generating convergence plots and other analysis.\n\ncurrent_lower_bound::Vector{Float64}: Storage for lower bound calculated for current node.\ncurrent_upper_bound::Vector{Float64}: Storage for upper bound calculated for current node.\npreprocessing_time::Vector{Float64}: Storage for preprocessing time of each iteration.\nlower_problem_time::Vector{Float64}: Storage for lower bounding time of each iteration.\nupper_problem_time::Vector{Float64}: Storage for upper bounding time of each iteration.\npostprocessing_time::Vector{Float64}: Storage for postprocessing time of each iteration.\npreprocessing_feas::Vector{Bool}: Storage for preprocessing feasibility of each iteration.\nlower_problem_feas::Vector{Bool}: Storage for lower bounding feasibility of each iteration.\nupper_problem_feas::Vector{Bool}: Storage for upper bounding feasibility of each iteration.\npostprocessing_feas::Vector{Bool}: Storage for postprocessing feasibility of each iteration.\nglobal_lower_bound::Vector{Float64}: Storage for best (global) lower bound at each iteration.\nglobal_upper_bound::Vector{Float64}: Storage for best (global) upper bound at each iteration.\n\n\n\n\n\n","category":"type"},{"location":"Optimizer/optimizer/#Extending-EAGO-1","page":"EAGO Optimizer","title":"Extending EAGO","text":"","category":"section"},{"location":"Optimizer/optimizer/#","page":"EAGO Optimizer","title":"EAGO Optimizer","text":"Functionality has been included that allows for extension's to EAGO's optimizer to readily be defined. This can be done in two ways first defining a new structure which is a subtype of EAGO.ExtensionType and overloading methods associated with this new structure. An instance of this new structure is provided to the EAGO.Optimizer using the ext_type keyword. This results in EAGO now dispatch to the new methods rather than the generally defined methods for the parent type. For a complete example, the reader is directed to the interval bounding example and quasiconvex example. Alternatively, the user can overload the optimize_hook! for this subtype which will entirely circumvent the default global solution routine. Additional information can be stored in the ext field of EAGO. In order to allow for compatibility between packages the user is encouraged to append their extension name to the start of each variable name (e.g. newext_newdata).","category":"page"},{"location":"McCormick/overview/#Overview-1","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"McCormick/overview/#","page":"Overview","title":"Overview","text":"EAGO provides a library of McCormick relaxations in native Julia code. It supports relaxing functions using both nonsmooth McCormick relaxations (Mitsos2009), smooth McCormick relaxations (Khan2017), multi-variant McCormick relaxations (Tsoukalas2014), as well as subgradient-based interval refinement (Najman2017). For functions with arbitrarily differentiable relaxations, the differentiable can be modified by adjusting a constant value. Additionally, and nonvalidated validated interval bounds are supported via ValidatedNumerics.jl.","category":"page"},{"location":"cite/#Citing-EAGO-1","page":"Citing EAGO","title":"Citing EAGO","text":"","category":"section"},{"location":"cite/#","page":"Citing EAGO","title":"Citing EAGO","text":"A paper about the EAGO software package is currently under preparation. In the meantime, please feel free to cite the conference presentation below:","category":"page"},{"location":"cite/#","page":"Citing EAGO","title":"Citing EAGO","text":"Wilhelm, Matthew; Stuber, Matthew (October 2017) Easy Advanced Global\nOptimization (EAGO): An Open-Source Platform for Robust and Global Optimization\nin Julia. Presented at the AIChE Annual Meeting in Minneapolis, MN.","category":"page"},{"location":"Optimizer/starting/#Solving-simple-example:-an-artificial-neural-network-with-EAGO-1","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"","category":"section"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"Matthew Wilhelm   Department of Chemical and Biomolecular Engineering, University of Connecticut","category":"page"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"In [1,2], a surrogate ANN model of bioreactor productivity was constructed by fitting results from computationally expensive CFD simulations. The author then optimized this surrogate model to obtain ideal processing conditions. This optimization problem is given by:","category":"page"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"\nbeginalign\n    labelprobANN1\n    max_mathbf xin X B_2 + sum_i=1^3frac2D_i1+exp(-2y_i) qquad textwhere qquad y_i =  B_i + sum_i=1^3sum_j=1^8 W_ijx_i\nendalign\n\n\nWell repeat this exercise using JuMP and EAGO\n\n Input parameters\n\nIn the first block we input parameters values supplied in the paper for W","category":"page"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":", B, D, and X into Julia as simple array objects.","category":"page"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"using JuMP, EAGO\n\n# Box constraints for input variables\nxLBD = [0.623   0.093   0.259   6.56   1114   0.013   0.127   0.004]\nxUBD = [5.89    0.5     1.0     90     25000  0.149   0.889   0.049]\n\n# Weights associated with the hidden layer\nW = [ 0.54  -1.97  0.09  -2.14  1.01  -0.58  0.45  0.26;\n     -0.81  -0.74  0.63  -1.60 -0.56  -1.05  1.23  0.93;\n     -0.11  -0.38 -1.19   0.43  1.21   2.78 -0.06  0.40]\n\n# Weights associated with the output layer\nD = [-0.91 0.11 0.52]\n\n# Bias associated with the hidden layer\nB1 = [-2.698 0.012 2.926]\n\n# Bias associated with the output layer\nB2 = -0.46","category":"page"},{"location":"Optimizer/starting/#Construct-the-JuMP-model-and-optimize-1","page":"Solving simple example: an artificial neural network with EAGO","title":"Construct the JuMP model and optimize","text":"","category":"section"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"We now formulate the problem using standard JuMP[3] syntax and optimize it. Note that we are forming an NLexpression object to handle the summation term to keep the code visually simple but this could be placed directly in the JuMP expressions instead.","category":"page"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"# Model construction\nmodel = Model(with_optimizer(EAGO.Optimizer, absolute_tolerance = 0.001))\n@variable(model, xLBD[i] <= x[i=1:8] <= xUBD[i])\n@NLexpression(model, prop[i=1:3], B1[i] + sum(W[i,j]*x[i] for j in 1:8))\n@NLobjective(model, Max, B2 + sum(D[i]*(2/(1+exp(-2*prop[i]))) for i=1:3))\n\n# Solves the model\noptimize!(model)","category":"page"},{"location":"Optimizer/starting/#Retrieve-results-1","page":"Solving simple example: an artificial neural network with EAGO","title":"Retrieve results","text":"","category":"section"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"We then recover the objective value, the solution value, and termination status codes using standard JuMP syntax.","category":"page"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"# Access calculated values\nfval = JuMP.objective_value(model)\nxsol = JuMP.value.(x)\nstatus_term = JuMP.termination_status(model)\nstatus_prim = JuMP.primal_status(model)\n\nprintln(\"EAGO terminated with a status of $status_term and a result code of $status_prim\")\nprintln(\"The optimal value is: $fval, the solution found is $xsol.\")","category":"page"},{"location":"Optimizer/starting/#Reference:-1","page":"Solving simple example: an artificial neural network with EAGO","title":"Reference:","text":"","category":"section"},{"location":"Optimizer/starting/#","page":"Solving simple example: an artificial neural network with EAGO","title":"Solving simple example: an artificial neural network with EAGO","text":"J. D. Smith, A. A. Neto, S. Cremaschi, and D. W. Crunkleton, CFD-based optimization of a flooded bed algae bioreactor, Industrial & Engineering Chemistry Research, 52 (2012), pp. 7181–7188\nA. M. Schweidtmann and A. Mitsos. Global Deterministic Optimization with Artificial Neural Networks Embedded https://arxiv.org/pdf/1801.07114.pdf\nIain Dunning and Joey Huchette and Miles Lubin. JuMP: A Modeling Language for Mathematical Optimization, SIAM Review, 59 (2017), pp. 295-320.","category":"page"},{"location":"McCormick/operators/#**Currently-supported-operators**-1","page":"Currently supported operators","title":"Currently supported operators","text":"","category":"section"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"The operators currently supported are listed below. The operators with a check box have been subject to a large degree of scrutiny and have been implemented for both forward and reverse McCormick relaxations.","category":"page"},{"location":"McCormick/operators/#**Univariate-McCormick-Operators**-1","page":"Currently supported operators","title":"Univariate McCormick Operators","text":"","category":"section"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"Arbitrarily differentiable relaxations can be constructed for the following operators:","category":"page"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"[x] Inverse (inv)\n[x] Logarithms (log, log2, log10)\n[x] Exponential Functions (exp, exp2, exp10)\n[x] Square Root (sqrt)\n[x] Absolute Value (abs)","category":"page"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"Both nonsmooth and Whitney-1 (once differentiable) relaxations are supported:","category":"page"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"[x] Step Functions (step, sign)\n[x] Trignometric Functions (sin, cos, tan)\n[x] Inverse Trignometric Functions (asin, acos, atan)\n[x] Hyperbolic Functions (sinh, cosh, tanh)\n[x] Inverse Hyperbolic Functions (asinh, acosh, atanh)","category":"page"},{"location":"McCormick/operators/#**Bivariate-Operators:-McCormick-and-McCormick**-1","page":"Currently supported operators","title":"Bivariate Operators: McCormick & McCormick","text":"","category":"section"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"The following bivariant operators are supported for two MC objects. Both nonsmooth and Whitney-1 (once differentiable) relaxations are supported.","category":"page"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"[x] multiplication (*)\n[x] division (/)","category":"page"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"Arbitrarily differentiable relaxations can be constructed for the following operators:","category":"page"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"[x] addition (+)\n[x] subtraction (-)\n[x] minimization (min)\n[x] maximization (max)","category":"page"},{"location":"McCormick/operators/#**Bivariate-Operators:-McCormick-and-(Integer-or-Float)**-1","page":"Currently supported operators","title":"Bivariate Operators: McCormick & (Integer or Float)","text":"","category":"section"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"Arbitrarily differentiable relaxations can be constructed for the following operators:","category":"page"},{"location":"McCormick/operators/#","page":"Currently supported operators","title":"Currently supported operators","text":"[x] addition (+)\n[x] subtraction (-)\n[x] multiplication (*)\n[x] division (/)\n[x] minimization (min)\n[x] maximization (max)\n[x] Exponentiation (pow, ^)","category":"page"},{"location":"ref/#**References**-1","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#*Branch-and-Bound*-1","page":"References","title":"Branch and Bound","text":"","category":"section"},{"location":"ref/#","page":"References","title":"References","text":"Floudas, Christodoulos A. Deterministic global optimization: theory, methods and applications. Vol. 37. Springer Science & Business Media, 2013.\nHorst, Reiner, and Hoang Tuy. Global optimization: Deterministic approaches. Springer Science & Business Media, 2013.","category":"page"},{"location":"ref/#*Parametric-Interval-Techniques*-1","page":"References","title":"Parametric Interval Techniques","text":"","category":"section"},{"location":"ref/#","page":"References","title":"References","text":"E. R. Hansen and G. W. Walster. Global Optimization Using Interval Analysis. Marcel Dekker, New York, second edition, 2004.\nR. Krawczyk. Newton-algorithmen zur bestimmung con nullstellen mit fehler-schranken. Computing, 4:187–201, 1969.\nR. Krawczyk. Interval iterations for including a set of solutions. Computing, 32:13–31, 1984.\nC. Miranda. Un’osservatione su un teorema di brower. Boll. Un. Mat. Ital., 3:5–7, 1940.\nA. Neumaier. Interval Methods for Systems of Equations. Cambridge University Press, Cambridge, 1990.\nR. E. Moore. A test for existence of solutions to nonlinear systems. SIAM Journal on Numerical Analysis, 14(4):611–615, 1977.","category":"page"},{"location":"ref/#*Domain-Reduction*-1","page":"References","title":"Domain Reduction","text":"","category":"section"},{"location":"ref/#","page":"References","title":"References","text":"Benhamou, F., & Older, W.J. (1997). Applying interval arithmetic to real, integer, and boolean constraints. The Journal of Logic Programming, 32, 1–24.\nCaprara, A., & Locatelli, M. (2010). Global optimization problems and domain reduction strategies. Mathematical Programming, 125, 123–137.\nGleixner, A.M., Berthold, T., Müller, B., & Weltge, S. (2016). Three enhancements for optimization-based bound tightening. ZIB Report, 15–16.\nRyoo, H.S., & Sahinidis, N.V. (1996). A branch-and-reduce approach to global optimization. Journal of Global Optimization, 8, 107–139.\nSchichl, H., & Neumaier, A. (2005). Interval analysis on directed acyclic graphs for global optimization. Journal of Global Optimization, 33, 541–562.\nTawarmalani, M., & Sahinidis, N.V. (2005). A polyhedral branch-and-cut approach to global optimization. Mathematical Programming, 103, 225–249.\nVu, X., Schichl, H., & Sam-Haroud, D. (2009). Interval propagation and search on directed acyclic graphs for numerical constraint solving. Journal of Global Optimization, 45, 499–531.","category":"page"},{"location":"ref/#*Generalized-McCormick-Relaxations*-1","page":"References","title":"Generalized McCormick Relaxations","text":"","category":"section"},{"location":"ref/#","page":"References","title":"References","text":"Chachuat, B.: MC++: a toolkit for bounding factorable functions, v1.0. Retrieved 2 July 2014 https://projects.coin-or.org/MCpp (2014)\nA. Mitsos, B. Chachuat, and P. I. Barton. McCormick-based relaxations of algorithms. SIAM Journal on Optimization, 20(2):573–601, 2009.\nG. P. McCormick. Computability of global solutions to factorable nonconvex programs: Part I-Convex underestimating problems. Mathematical Programming, 10:147–175, 1976.\nG. P. McCormick. Nonlinear programming: Theory, Algorithms, and Applications. Wiley, New York, 1983.\nJ. K. Scott, M. D. Stuber, and P. I. Barton. Generalized McCormick relaxations. Journal of Global Optimization, 51(4):569–606, 2011.\nStuber, M.D., Scott, J.K., Barton, P.I.: Convex and concave relaxations of implicit functions. Optim. Methods Softw. 30(3), 424–460 (2015)\nA. Tsoukalas and A. Mitsos. Multivariate McCormick Relaxations. Journal of Global Optimization, 59:633–662, 2014.\nK.A. Khan, HAJ Watson, P.I. Barton. Differentiable McCormick relaxations. Journal of Global Optimization, 67(4):687-729 (2017).\nA., Wechsung JK Scott, HAJ Watson, and PI Barton. Reverse propagation of McCormick relaxations. Journal of Global Optimization 63(1):1-36 (2015).","category":"page"},{"location":"ref/#*Semi-Infinite-Programming*-1","page":"References","title":"Semi-Infinite Programming","text":"","category":"section"},{"location":"ref/#","page":"References","title":"References","text":"A. Mitsos. Global optimization of semi-infinite programs via restriction of the right-hand side. Optimization, 60(10-11):1291-1308, 2009.\nStuber, M.D. and Barton, P. I. Semi-Infinite Optimization With Implicit Functions. Industrial & Engineering Chemistry Research, 54:307-317, 2015.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: full_Logo)","category":"page"},{"location":"#**EAGO-Easy-Advanced-Global-Optimization-in-Julia**-1","page":"Introduction","title":"EAGO - Easy Advanced Global Optimization in Julia","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"A flexible-framework for global and robust optimization in Julia","category":"page"},{"location":"#Authors-1","page":"Introduction","title":"Authors","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Matthew Wilhelm, Department of Chemical and Biomolecular Engineering,  University of Connecticut (UCONN)","category":"page"},{"location":"#Overview-1","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"EAGO is a global and robust optimization platform based on McCormick relaxations. It contains the first widely accessible global optimization routine based on generalized McCormick relaxations. With the exception of calls to local solvers and linear algebra routines, EAGO is written entirely in native Julia. The solver is quite flexibly arranged so the end user can easily customize low-level routines.","category":"page"},{"location":"#Installing-EAGO-1","page":"Introduction","title":"Installing EAGO","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"EAGO is registered Julia package. It can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run the following command","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"pkg> add EAGO","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Currently, EAGO is tied to a 0.19 or greater version of JuMP. This allows a replication of some of the internal features shared by EAGO and JuMP's AD scheme aka generation of Wergert Tapes pass evaluators between JuMP and EAGO etc.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"pkg> add JuMP","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Once JuMP 0.19+ is registered EAGO will be updated to eliminate the need for this.","category":"page"},{"location":"#Examples-1","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"A few examples are provided in the documentation website. More involved examples are provided at in the form of Jupyter Notebooks at EAGO-notebooks and can be run using IJulia. To add IJulia","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"pkg> add IJulia","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Then launch the Jupyter notebook using the following command from the Julia terminal,","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using IJulia; notebook()","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Then simply navigate to the example directory and run the example of most interest.","category":"page"}]
}
